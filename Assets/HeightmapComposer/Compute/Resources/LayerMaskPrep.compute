#pragma kernel CopyMaskFromTex
#pragma kernel FillNoiseMask
#pragma kernel BlurH
#pragma kernel BlurV

Texture2DArray<float4> _LayerTexArray;
Texture2DArray<float>  _PaintMaskArray; // optional
RWTexture2DArray<float> _MaskArray;
RWTexture2DArray<float> _TempArray;

int _Resolution;
int _SliceSrc;
int _SliceDst;
int _SlicePaint;   // -1 if none
float _SigmaPixels;

// Noise params
float _TileMeters;
float4 _AreaMinMax;
float _Frequency, _Persistence, _Lacunarity;
int _Octaves;
int _OutputMaskFromHeight;
float _MaskThreshold, _MaskSmooth;
int _NoiseType; // 0..3
float _WarpAmountMeters, _WarpFrequency;

float2 hash2(float2 p){ p=float2(dot(p,float2(127.1,311.7)),dot(p,float2(269.5,183.3))); return frac(sin(p)*43758.5453); }
float perlin_fallback(float2 p)
{
    float2 i=floor(p), f=frac(p);
    float2 u=f*f*(3-2*f);
    float2 a=hash2(i+float2(0,0));
    float2 b=hash2(i+float2(1,0));
    float2 c=hash2(i+float2(0,1));
    float2 d=hash2(i+float2(1,1));
    float n=lerp(lerp(dot(a,f-0),dot(b,f-float2(1,0)),u.x),
                 lerp(dot(c,f-float2(0,1)),dot(d,f-float2(1,1)),u.x),u.y);
    return saturate(n*0.5+0.5)*2-1;
}
float perlin2(float2 p){ return perlin_fallback(p); }
float fractal(float2 p,int oct,float pers,float lac)
{
    float sum=0,amp=1,freq=1,norm=0;
    [loop] for(int i=0;i<oct;i++){ sum+=amp*perlin2(p*freq); norm+=amp; amp*=pers; freq*=lac; }
    return sum/max(norm,1e-6);
}

[numthreads(8,8,1)]
void CopyMaskFromTex(uint3 id:SV_DispatchThreadID)
{
    if(id.x>=_Resolution||id.y>=_Resolution) return;
    float m = _LayerTexArray.Load(int4(id.xy, _SliceSrc, 0)).g;
    if (_SlicePaint >= 0)
    {
        float pm = _PaintMaskArray.Load(int4(id.xy, _SlicePaint, 0)).r;
        m *= pm;
    }
    _MaskArray[id.xy][_SliceDst] = m;
}

[numthreads(8,8,1)]
void FillNoiseMask(uint3 id:SV_DispatchThreadID)
{
    if(id.x>=_Resolution||id.y>=_Resolution) return;
    float2 uv=(float2(id.xy)+0.5)/_Resolution;
    float2 meters=uv*_TileMeters;
    float2 p=meters;
    if(_NoiseType==3 && _WarpAmountMeters>0.0001)
    {
        float2 v=0; float amp=1,freq=1;
        [unroll] for(int k=0;k<2;k++){ float nx=perlin2(meters*freq); float ny=perlin2((meters+float2(19.17,-7.31))*freq); v+=float2(nx,ny)*amp; amp*=0.5; freq*=2; }
        p += v * _WarpAmountMeters;
    }
    float n=fractal(p*_Frequency,_Octaves,_Persistence,_Lacunarity);
    if(_NoiseType==1) n=1-abs(n); else if(_NoiseType==2) n=abs(n);
    float hh=saturate(n*0.5+0.5);
    float m=1.0;
    if(_OutputMaskFromHeight!=0)
    {
        float t0=saturate(_MaskThreshold-_MaskSmooth);
        float t1=saturate(_MaskThreshold+_MaskSmooth);
        m=smoothstep(0,1, saturate((hh-t0)/max(t1-t0,1e-6)));
    }
    if (_SlicePaint >= 0)
    {
        float pm = _PaintMaskArray.Load(int4(id.xy, _SlicePaint, 0)).r;
        m *= pm;
    }
    _MaskArray[id.xy][_SliceDst]=m;
}

void BuildWeights(out float w0,out float w1,out float w2,out float w3,out float w4,float sigma)
{
    float r0=0,r1=1,r2=2,r3=3,r4=4;
    float s2=2.0*sigma*sigma+1e-6;
    w0=exp(-(r0*r0)/s2);
    w1=exp(-(r1*r1)/s2);
    w2=exp(-(r2*r2)/s2);
    w3=exp(-(r3*r3)/s2);
    w4=exp(-(r4*r4)/s2);
    float norm = w0 + 2*(w1+w2+w3+w4);
    w0/=norm; w1/=norm; w2/=norm; w3/=norm; w4/=norm;
}

[numthreads(8,8,1)]
void BlurH(uint3 id:SV_DispatchThreadID)
{
    if(id.x>=_Resolution||id.y>=_Resolution) return;
    float w0,w1,w2,w3,w4; BuildWeights(w0,w1,w2,w3,w4, max(_SigmaPixels,0.001));
    int2 p=int2(id.xy); int s=_SliceDst; int X=_Resolution;
    int2 p0=int2(p.x,p.y);
    int2 p1a=int2(max(p.x-1,0),p.y), p1b=int2(min(p.x+1,X-1),p.y);
    int2 p2a=int2(max(p.x-2,0),p.y), p2b=int2(min(p.x+2,X-1),p.y);
    int2 p3a=int2(max(p.x-3,0),p.y), p3b=int2(min(p.x+3,X-1),p.y);
    int2 p4a=int2(max(p.x-4,0),p.y), p4b=int2(min(p.x+4,X-1),p.y);
    float m = w0*_MaskArray[p0][s]
            + w1*(_MaskArray[p1a][s]+_MaskArray[p1b][s])
            + w2*(_MaskArray[p2a][s]+_MaskArray[p2b][s])
            + w3*(_MaskArray[p3a][s]+_MaskArray[p3b][s])
            + w4*(_MaskArray[p4a][s]+_MaskArray[p4b][s]);
    _TempArray[p][s]=m;
}
[numthreads(8,8,1)]
void BlurV(uint3 id:SV_DispatchThreadID)
{
    if(id.x>=_Resolution||id.y>=_Resolution) return;
    float w0,w1,w2,w3,w4; BuildWeights(w0,w1,w2,w3,w4, max(_SigmaPixels,0.001));
    int2 p=int2(id.xy); int s=_SliceDst; int Y=_Resolution;
    int2 p0=int2(p.x,p.y);
    int2 p1a=int2(p.x,max(p.y-1,0)), p1b=int2(p.x,min(p.y+1,Y-1));
    int2 p2a=int2(p.x,max(p.y-2,0)), p2b=int2(p.x,min(p.y+2,Y-1));
    int2 p3a=int2(p.x,max(p.y-3,0)), p3b=int2(p.x,min(p.y+3,Y-1));
    int2 p4a=int2(p.x,max(p.y-4,0)), p4b=int2(p.x,min(p.y+4,Y-1));
    float m = w0*_TempArray[p0][s]
            + w1*(_TempArray[p1a][s]+_TempArray[p1b][s])
            + w2*(_TempArray[p2a][s]+_TempArray[p2b][s])
            + w3*(_TempArray[p3a][s]+_TempArray[p3b][s])
            + w4*(_TempArray[p4a][s]+_TempArray[p4b][s]);
    _MaskArray[p][s]=m;
}
